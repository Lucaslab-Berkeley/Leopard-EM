{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Py2DTM","text":"<p>Two-dimensional template-matching (2DTM) for in situ structural biology implemented in Python. This package reflects most of the functionality described in Lucas, et al. (2021)[^1].</p>"},{"location":"#installation","title":"Installation","text":"<p>Pre-packaged versions of Py2DTM are released on the Python Package Index (PyPI). We target Linux operating systems on Python 3.9 and above for these releases, and the PyTorch GPU acceleration backend is only tested against NVIDIA GPUs. With these caveats in mind, the package can be installed using pip:</p> <pre><code>pip install py2dtm\n</code></pre> <p>We also recommend you install the package in a virtual environment (such as conda) to avoid conflicts with other packages.</p>"},{"location":"#installing-from-source","title":"Installing from Source","text":"<p>To install the package from source, first clone the repository and install the package using pip:</p> <pre><code>git clone https://github.com/jdickerson95/tt2DTM.git\ncd tt2DTM\npip install .\n</code></pre>"},{"location":"#for-developers","title":"For Developers","text":"<p>For developers interested in contributing to the package, we recommend installing the package in an editable configuration with the necessary development dependencies:</p> <pre><code>git clone https://github.com/jdickerson95/tt2DTM.git\ncd tt2DTM\npip install -e '.[dev,test,docs]'\n</code></pre> <p>See the Contributing section for more information on how to contribute to the package.</p>"},{"location":"#basic-usage","title":"Basic Usage","text":"<p>A minimally working example of running the <code>match_template</code> program in a python script is shown below. Please see the examples page for more extensive explanations and demonstrations on how to configure, use, and extend the package.</p> <pre><code>from tt2dtm.pydantic_models import MatchTemplateManager\nfrom tt2dtm.pydantic_models import MatchTemplateResult\nfrom tt2dtm.pydantic_models import OpticsGroup\nfrom tt2dtm.pydantic_models import DefocusSearchConfig\nfrom tt2dtm.pydantic_models import OrientationSearchConfig\n\n# Microscope imaging parameters\nmy_optics_group = OpticsGroup(\n    label=\"my_optics_group\",\n    pixel_size=1.2,    # In Angstroms\n    voltage=300,       # In kV\n    defocus_u=5100.0,  # In Angstroms\n    defocus_v=4900.0,  # In Angstroms\n    astigmatism_angle=0.0,  # In degrees\n)\n\n# Relative defocus planes to search across\ndf_search_config = DefocusSearchConfig(\n    label=\"defocus_search\",\n    min_defocus=1000,   # In Angstroms, relative\n    max_defocus=-1000,  # In Angstroms, relative\n    step_size=200.0,    # In Angstroms\n)\n\n# Orientation sampling of SO(3) space\norientation_search_config = OrientationSearchConfig()\n\n# Where to save the output results\nmt_result = MatchTemplateResult(\n    allow_file_overwrite=True,\n    mip_path=\"/path/to/output_mip.mrc\",\n    scaled_mip_path=\"/path/to/output_scaled_mip.mrc\",\n    correlation_average_path=\"/path/to/output_correlation_average.mrc\",\n    correlation_variance_path=\"/path/to/output_correlation_variance.mrc\",\n    orientation_psi_path=\"/path/to/output_orientation_psi.mrc\",\n    orientation_theta_path=\"/path/to/output_orientation_theta.mrc\",\n    orientation_phi_path=\"/path/to/output_orientation_phi.mrc\",\n    relative_defocus_path=\"/path/to/output_relative_defocus.mrc\",\n    pixel_size_path=\"/path/to/output_pixel_size.mrc\",\n)\n\nmt_manager = MatchTemplateManager(\n    micrograph_path=\"/path/to/2D_image.mrc\",\n    template_volume_path=\"/path/to/template_volume.mrc\",\n    optics_group=my_optics_group,\n    defocus_search_config=df_search_config,\n    orientation_search_config=orientation_search_config,\n    match_template_result=mt_result,\n    # pixel_size_search_config\n    # preprocessing_filters\n    # computational_config\n)\n\n\ndef main():\n    # Batch size helps control GPU memory usage\n    mt_manager.run_match_template(orientation_batch_size=8)\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"#documentation-and-examples","title":"Documentation and Examples","text":"<p>TODO</p>"},{"location":"#theory","title":"Theory","text":"<p>TODO</p>"},{"location":"#api","title":"API","text":"<p>TODO: Get some autodocs to parse the docstrings and generate API documentation.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>We encourage contributions to this package from the broader cryo-EM/ET and structural biology communities. Py2DTM is configured with a set of development dependencies to help contributors maintain code quality and consistency. See the Installation -- For Developers section for instructions on how to install these dependencies.</p>"},{"location":"#using-pre-commit","title":"Using <code>pre-commit</code>","text":"<p>The <code>pre-commit</code> package is used to run a set of code quality checks and auto-formatters on the codebase. If this is your first time installing the package, you will need to install the pre-commit hooks:</p> <pre><code>pre-commit install--install-hooks\n</code></pre> <p>After staging changes, but before making a commit, you can run the pre-commit checks with:</p> <pre><code>pre-commit run\n</code></pre> <p>This will go through the staged files, check that all the changed code adheres to the style guidelines, and auto-format the code where necessary. If all the tests pass, you can commit the changes.</p>"},{"location":"#running-tests","title":"Running Tests","text":"<p>Py2DTM uses the <code>pytest</code> package for running tests. To run the tests, simply run the following command from the root directory of the repository:</p> <pre><code>pytest\n</code></pre> <p>Note that we are still working on expanding the unit tests to cover more of the package, but we ask that any new code contributions include tests where appropriate.</p>"},{"location":"#building-documentation","title":"Building Documentation","text":"<p>The documentation for Py2DTM is built using MkDocs and Material for MkDocs for generating the documentation site. If you've installed the package with the optional <code>docs</code> dependencies, you can build the documentation site with the following command:</p> <pre><code>mkdocs build\nmkdocs serve\n</code></pre> <p>The first command will construct the HTML files for the documentation site, and the second command will start a local server (at <code>127.0.0.1:8000</code>) to view the site.</p>"},{"location":"#license","title":"License","text":"<p>The code in this repository is licensed under the BSD 3-Clause License. See the LICENSE file for full details.</p>"},{"location":"#references","title":"References","text":"<p>[^1]: Lucas BA, Himes BA, Xue L, Grant T, Mahamid J, Grigorieff N. Locating macromolecular assemblies in cells by 2D template matching with cisTEM. Elife. 2021 Jun 11;10:e68946. doi: 10.7554/eLife.68946. PMID: 34114559; PMCID: PMC8219381.</p>"},{"location":"data_formats/","title":"Description of Data Formats","text":"<p>To increase interoperability between external packages, we herein describe the different data formats used as input to and export from programs. Orientations on a per-particle bases are currently stored as Euler angles in ZYZ format. Note that the package is still under development and the exact way the data is represented might change in the future.</p>"},{"location":"data_formats/#data-from-the-match-template-program","title":"Data from the match template program","text":"<p>The match template program collates statistics from a large number of cross-correlograms taken over an orientation and defocus search space. See the API on the <code>MatchTemplateResult</code> object for further information on how these data are stored, but here we provide an overview of what files get written to disk.</p>"},{"location":"data_formats/#best-statistic-maps","title":"Best statistic maps","text":"<p>Each of the \"best\" statistics is stored on a per-position basis in what we dub \"statistics maps\" saved as <code>.mrc</code> files. We have the following tracked statistics for each valid (x, y) position:</p> <ul> <li>Maximum Intensity Projection (MIP): Maximum cross-correlation value over all search orientations and relative defocus values.</li> <li>Scaled MIP (z-score or SNR): The MIP value normalized by the mean and variance of the cross-correlation over the entire search space.</li> <li>Correlation Mean: The mean of the cross-correlation values over the entire search space. Used to calculate the scaled MIP.</li> <li>Correlation Variance: The variance of the cross-correlation values over the entire search space. Used to calculate the scaled MIP.</li> <li>Phi: The  angle which (in degrees) produced the MIP value.</li> <li>Theta: The  angle (in degrees) which produced the MIP value.</li> <li>Psi: The  angle (in degrees) which produced the MIP value.</li> <li>Defocus: The relative defocus value (in Angstroms) which produced the MIP value.</li> </ul>"},{"location":"data_formats/#a-note-on-correlation-modes-and-output-shapes","title":"A note on correlation modes and output shapes","text":"<p>Three general modes for convolution/correlation exist in digital signal processing: \"full\", \"same\", and \"valid\". This chapter of Digital Signals Theory provides a good overview of these modes.</p> <p>We support both the \"same\" and \"valid\" modes for cross-correlation. For an image with shape  and template , the modes will output statistics maps with the following shapes:</p> <ul> <li>same:  </li> <li>valid:  </li> </ul> <p>Note that same mode pads the image with zeros along the edges and does not increase the number of particles detectable; values along the padded portions of the edge do not hold significance in the context of the particle detection. In each case, the position in the map at  corresponds to the top-left corner of the template at that position, not the center of the template. Below is an example comparing the two correlation modes:</p> <p>HWhwW-w+1H-h+1validimagetemplateH+h-1W+w-1hwWHsamezero paddingimagetemplate</p>"},{"location":"data_formats/#match-template-dataframe","title":"Match template DataFrame","text":"<p>Since not all positions  contain a particle from the match template search, using only the statistics maps can be inefficient in terms of size and speed. The match template manager class has the method <code>MatchTemplateManager.results_to_dataframe()</code> which automatically picks peaks within the scaled MIP map and stores the peak locations, orientations, and defocus values in a pandas DataFrame.</p> <p>Additional columns besides locations and orientations are included in the DataFrame to increase the utility of the data, namely the construction of <code>ParticleStack</code> objects. The columns and corresponding descriptions are as follows:</p> Column Name Type Description <code>mip</code> float Maximum cross-correlation value over all search orientations and relative defocus values. <code>scaled_mip</code> float Scaled MIP value (z-score) normalized by cross-correlation mean and variance. <code>correlation_mean</code> float Mean of the cross-correlation values over the entire search space. <code>correlation_variance</code> float Variance of the cross-correlation values over the entire search space. <code>total_correlations</code> int Total number of cross-correlations taken over the search space (defoci times orientations). <code>pos_x</code> int Particle x position (units of pixels) in the statistics maps. Corresponds to the top-left corner of the template. <code>pos_y</code> int Particle y position (units of pixels) in the statistics maps. Corresponds to the top-left corner of the template. <code>pos_x_img</code> int Center of of the particle (x position, units of pixels) in the micrograph. <code>pos_y_img</code> int Center of of the particle (y position, units of pixels) in the micrograph. <code>pos_x_img_angstrom</code> float Center of the particle (x position, in Angstroms) in the micrograph. <code>pos_y_img_angstrom</code> float Center of the particle (y position, in Angstroms) in the micrograph. <code>psi</code> float The  angle (in degrees) which produced the MIP value. <code>theta</code> float The  angle (in degrees) which produced the MIP value. <code>phi</code> float The  angle which (in degrees) produced the MIP value. <code>relative_defocus</code> float The relative defocus value (in Angstroms) which produced the MIP value. Relative to <code>defocus_u</code> and <code>defocus_v</code>. <code>defocus_u</code> float Defocus value along the major axis for the micrograph (in Angstroms). <code>defocus_v</code> float Defocus value along the minor axis for the micrograph (in Angstroms). <code>astigmatism_angle</code> float Angle of the astigmatism (in degrees) for defocus. <code>pixel_size</code> float Pixel size of the micrograph (in Angstroms). <code>voltage</code> float Voltage of the microscope (in kV). <code>spherical_aberration</code> float Spherical aberration of the microscope (in mm). <code>amplitude_contrast_ratio</code> float Amplitude contrast ratio of the microscope. <code>phase_shift</code> float Phase shift of the microscope (in degrees). <code>ctf_B_factor</code> float B-factor of the CTF, in Angstroms^2. <code>micrograph_path</code> str Path to the original micrograph. <code>template_path</code> str Path to the template used for the search. <code>mip_path</code> str Path to the saved MIP map. <code>scaled_mip_path</code> str Path to the saved scaled MIP map. <code>psi_path</code> str Path to the saved psi map. <code>theta_path</code> str Path to the saved theta map. <code>phi_path</code> str Path to the saved phi map. <code>defocus_path</code> str Path to the saved defocus map. <code>correlation_average_path</code> str Path to the saved correlation mean map. <code>correlation_variance_path</code> str Path to the saved correlation variance map."},{"location":"data_formats/#data-from-the-refine-template-program","title":"Data from the refine template program","text":"<p>The refine template program takes in a set of particles and refined their orientations and relative defocus values.</p>"},{"location":"data_formats/#refine-template-dataframe","title":"Refine template DataFrame","text":"<p>The program outputs another DataFrame with additional columns for the refined orientations, defocus values, and positions. New columns are listed below:</p> Column Name Type Description <code>refined_mip</code> float New maximum cross-correlation over refinement search space. <code>refined_scaled_mip</code> float New scaled MIP value (z-score) normalized by cross-correlation mean and variance. <code>refined_pos_x</code> int The refined x position of the particle, top-left corner of the template. <code>refined_pos_y</code> int The refined y position of the particle, top-left corner of the template. <code>refined_pos_x_img</code> int The refined x position of the particle, center of the particle in the micrograph. <code>refined_pos_y_img</code> int The refined y position of the particle, center of the particle in the micrograph. <code>refined_pos_x_img_angstrom</code> float The refined x position of the particle, center of the particle in the micrograph (in Angstroms). <code>refined_pos_y_img_angstrom</code> float The refined y position of the particle, center of the particle in the micrograph (in Angstroms). <code>refined_psi</code> float The refined  angle (in degrees). <code>refined_theta</code> float The refined  angle (in degrees). <code>refined_phi</code> float The refined  angle (in degrees). <code>refined_relative_defocus</code> float The refined relative defocus value (in Angstroms)."},{"location":"examples/basic_configuration/","title":"Template Matching Configurations","text":"In\u00a0[1]: Copied! <pre>from pprint import pprint\n\nfrom tt2dtm.pydantic_models import (\n    ArbitraryCurveFilterConfig,\n    BandpassFilterConfig,\n    ComputationalConfig,\n    DefocusSearchConfig,\n    MatchTemplateManager,\n    MatchTemplateResult,\n    OpticsGroup,\n    OrientationSearchConfig,\n    PhaseRandomizationFilterConfig,\n    PreprocessingFilters,\n    WhiteningFilterConfig,\n)\n</pre> from pprint import pprint  from tt2dtm.pydantic_models import (     ArbitraryCurveFilterConfig,     BandpassFilterConfig,     ComputationalConfig,     DefocusSearchConfig,     MatchTemplateManager,     MatchTemplateResult,     OpticsGroup,     OrientationSearchConfig,     PhaseRandomizationFilterConfig,     PreprocessingFilters,     WhiteningFilterConfig, ) In\u00a0[2]: Copied! <pre>my_optics_group = OpticsGroup(\n    label=\"my_optics_group\",\n    pixel_size=1.06,\n    voltage=300.0,\n    spherical_aberration=2.7,  # default value\n    amplitude_contrast_ratio=0.07,  # default value\n    phase_shift=0.0,  # default value\n    defocus_u=5200.0,\n    defocus_v=4950.0,\n    astigmatism_angle=25.0,\n    ctf_B_factor=60.0,\n)\n</pre> my_optics_group = OpticsGroup(     label=\"my_optics_group\",     pixel_size=1.06,     voltage=300.0,     spherical_aberration=2.7,  # default value     amplitude_contrast_ratio=0.07,  # default value     phase_shift=0.0,  # default value     defocus_u=5200.0,     defocus_v=4950.0,     astigmatism_angle=25.0,     ctf_B_factor=60.0, ) <p>The Python variable <code>my_optics_group</code> is now an instance of the <code>OpticsGroup</code> model. Note that the model does do validation under-the-hood to ensure necessary fields are present and valid. Any invalid fields will raise a <code>ValidationError</code> when the model is created. Uncomment the following code block to see this in action.</p> In\u00a0[3]: Copied! <pre># bad_optics_group = OpticsGroup(\n#     label=\"bad_optics_group\",\n#     pixel_size=-1.0,  # &lt;--- Must be positive\n#     voltage=300.0,\n#     phase_shift=0.0,  # default value\n#     defocus_u=5200.0,\n#     defocus_v=4950.0,\n#     astigmatism_angle=25.0,\n# )\n</pre> # bad_optics_group = OpticsGroup( #     label=\"bad_optics_group\", #     pixel_size=-1.0,  # &lt;--- Must be positive #     voltage=300.0, #     phase_shift=0.0,  # default value #     defocus_u=5200.0, #     defocus_v=4950.0, #     astigmatism_angle=25.0, # ) In\u00a0[4]: Copied! <pre>optics_dict = my_optics_group.model_dump()\npprint(optics_dict)\n</pre> optics_dict = my_optics_group.model_dump() pprint(optics_dict) <pre>{'amplitude_contrast_ratio': 0.07,\n 'astigmatism_angle': 25.0,\n 'beam_tilt_x': None,\n 'beam_tilt_y': None,\n 'chromatic_aberration': 0.0,\n 'ctf_B_factor': 60.0,\n 'defocus_u': 5200.0,\n 'defocus_v': 4950.0,\n 'even_zernike': None,\n 'label': 'my_optics_group',\n 'mtf_reference': None,\n 'mtf_values': None,\n 'odd_zernike': None,\n 'phase_shift': 0.0,\n 'pixel_size': 1.06,\n 'spherical_aberration': 2.7,\n 'voltage': 300.0,\n 'zernike_moments': None}\n</pre> In\u00a0[5]: Copied! <pre>yaml_filepath = \"./optics_group_example.yaml\"\nmy_optics_group.to_yaml(yaml_filepath)\n</pre> yaml_filepath = \"./optics_group_example.yaml\" my_optics_group.to_yaml(yaml_filepath) <p>A new file called <code>optics_group_example.yaml</code> should now exist in the current working directory with the following contents:</p> <pre>amplitude_contrast_ratio: 0.07\nbeam_tilt_x: null\nbeam_tilt_y: null\nchromatic_aberration: 0.0\nctf_B_factor: 60.0\nastigmatism_angle: 25.0\ndefocus_u: 5200.0\ndefocus_v: 4950.0\neven_zernike: null\nlabel: my_optics_group\nmtf_reference: null\nmtf_values: null\nodd_zernike: null\nphase_shift: 0.0\npixel_size: 1.06\nspherical_aberration: 2.7\nvoltage: 300.0\nzernike_moments: null\n</pre> In\u00a0[6]: Copied! <pre>new_optics_group = OpticsGroup.from_yaml(yaml_filepath)\n\n# Check if the two OpticsGroup objects are equal\nif new_optics_group == my_optics_group:\n    print(\"OpticsGroup objects are equal.\")\nelse:\n    print(\"The two OpticsGroup are not equal!!!\")\n</pre> new_optics_group = OpticsGroup.from_yaml(yaml_filepath)  # Check if the two OpticsGroup objects are equal if new_optics_group == my_optics_group:     print(\"OpticsGroup objects are equal.\") else:     print(\"The two OpticsGroup are not equal!!!\") <pre>OpticsGroup objects are equal.\n</pre> <p>Now that we've covered the basics of creating, serializing, and deserializing the <code>OpticsGroup</code> model, we can move onto the next models without covering the (de)serialization and import/export steps in detail.</p> <p>Below, we create a new instance of the <code>OrientationSearchConfig</code> model with only the <code>in_plane_step</code> and <code>out_of_plane_step</code> attributes set to non-default values.</p> In\u00a0[7]: Copied! <pre>orientation_search_config = OrientationSearchConfig(\n    in_plane_step=4.0,\n    out_of_plane_step=4.0,\n)\n\n# print the model dictionary\norientation_search_config.model_dump()\n</pre> orientation_search_config = OrientationSearchConfig(     in_plane_step=4.0,     out_of_plane_step=4.0, )  # print the model dictionary orientation_search_config.model_dump() Out[7]: <pre>{'in_plane_step': 4.0,\n 'out_of_plane_step': 4.0,\n 'psi_min': 0.0,\n 'psi_max': 360.0,\n 'theta_min': 0.0,\n 'theta_max': 180.0,\n 'phi_min': 0.0,\n 'phi_max': 360.0,\n 'base_grid_method': 'uniform'}</pre> In\u00a0[8]: Copied! <pre># Searches defocus between -600 and 600 with a step of 200 Angstroms\ndefocus_search_config = DefocusSearchConfig(\n    enabled=True, defocus_min=-600, defocus_max=600, defocus_step=200\n)\n</pre> # Searches defocus between -600 and 600 with a step of 200 Angstroms defocus_search_config = DefocusSearchConfig(     enabled=True, defocus_min=-600, defocus_max=600, defocus_step=200 ) In\u00a0[9]: Copied! <pre>defocus_search_config.defocus_values\n</pre> defocus_search_config.defocus_values Out[9]: <pre>[-600.0, -400.0, -200.0, 0.0, 200.0, 400.0, 600.0]</pre> In\u00a0[10]: Copied! <pre>whitening_filter_config = WhiteningFilterConfig()\n</pre> whitening_filter_config = WhiteningFilterConfig() In\u00a0[11]: Copied! <pre>bandpass_filter_config = BandpassFilterConfig()\n</pre> bandpass_filter_config = BandpassFilterConfig() In\u00a0[12]: Copied! <pre>phase_randomization_filter = PhaseRandomizationFilterConfig()\n</pre> phase_randomization_filter = PhaseRandomizationFilterConfig() In\u00a0[13]: Copied! <pre>arbitrary_curve_filter = ArbitraryCurveFilterConfig()\n</pre> arbitrary_curve_filter = ArbitraryCurveFilterConfig() In\u00a0[14]: Copied! <pre>preprocessing_filters = PreprocessingFilters(\n    whitening_filter=whitening_filter_config,\n    bandpass_filter=bandpass_filter_config,\n    phase_randomization_filter=phase_randomization_filter,\n    arbitrary_curve_filter=arbitrary_curve_filter,\n)\n</pre> preprocessing_filters = PreprocessingFilters(     whitening_filter=whitening_filter_config,     bandpass_filter=bandpass_filter_config,     phase_randomization_filter=phase_randomization_filter,     arbitrary_curve_filter=arbitrary_curve_filter, ) In\u00a0[15]: Copied! <pre>comp_config = ComputationalConfig()\ncomp_config\n</pre> comp_config = ComputationalConfig() comp_config Out[15]: <pre>ComputationalConfig(gpu_ids=[0], num_cpus=1)</pre> In\u00a0[16]: Copied! <pre>match_template_result = MatchTemplateResult(\n    allow_file_overwrite=True,\n    mip_path=\"./output_mip.mrc\",\n    scaled_mip_path=\"./output_scaled_mip.mrc\",\n    correlation_average_path=\"./output_correlation_average.mrc\",\n    correlation_variance_path=\"./output_correlation_variance.mrc\",\n    orientation_psi_path=\"./output_orientation_psi.mrc\",\n    orientation_theta_path=\"./output_orientation_theta.mrc\",\n    orientation_phi_path=\"./output_orientation_phi.mrc\",\n    relative_defocus_path=\"./output_relative_defocus.mrc\",\n)\n</pre> match_template_result = MatchTemplateResult(     allow_file_overwrite=True,     mip_path=\"./output_mip.mrc\",     scaled_mip_path=\"./output_scaled_mip.mrc\",     correlation_average_path=\"./output_correlation_average.mrc\",     correlation_variance_path=\"./output_correlation_variance.mrc\",     orientation_psi_path=\"./output_orientation_psi.mrc\",     orientation_theta_path=\"./output_orientation_theta.mrc\",     orientation_phi_path=\"./output_orientation_phi.mrc\",     relative_defocus_path=\"./output_relative_defocus.mrc\", ) In\u00a0[17]: Copied! <pre>match_template_manager = MatchTemplateManager(\n    micrograph_path=\"./dummy_micrograph.mrc\",\n    template_volume_path=\"./dummy_template_volume.mrc\",\n    optics_group=my_optics_group,\n    defocus_search_config=defocus_search_config,\n    orientation_search_config=orientation_search_config,\n    preprocessing_filters=preprocessing_filters,\n    match_template_result=match_template_result,\n    computational_config=comp_config,\n    preload_mrc_files=False,  # Don't try to read the MRC upon initialization\n)\n</pre> match_template_manager = MatchTemplateManager(     micrograph_path=\"./dummy_micrograph.mrc\",     template_volume_path=\"./dummy_template_volume.mrc\",     optics_group=my_optics_group,     defocus_search_config=defocus_search_config,     orientation_search_config=orientation_search_config,     preprocessing_filters=preprocessing_filters,     match_template_result=match_template_result,     computational_config=comp_config,     preload_mrc_files=False,  # Don't try to read the MRC upon initialization ) In\u00a0[18]: Copied! <pre>match_template_manager.to_yaml(\"./match_template_manager_example.yaml\")\n</pre> match_template_manager.to_yaml(\"./match_template_manager_example.yaml\") In\u00a0[19]: Copied! <pre>new_match_template_manager = MatchTemplateManager.from_yaml(\n    \"./match_template_manager_example.yaml\"\n)\n\nif new_match_template_manager == match_template_manager:\n    print(\"MatchTemplateManager objects are equal.\")\nelse:\n    print(\"The two MatchTemplateManager are not equal!!!\")\n</pre> new_match_template_manager = MatchTemplateManager.from_yaml(     \"./match_template_manager_example.yaml\" )  if new_match_template_manager == match_template_manager:     print(\"MatchTemplateManager objects are equal.\") else:     print(\"The two MatchTemplateManager are not equal!!!\") <pre>MatchTemplateManager objects are equal.\n</pre>"},{"location":"examples/basic_configuration/#template-matching-configurations","title":"Template Matching Configurations\u00b6","text":"<p>This example notebook outlines the steps necessary to generate, save, and load configurations for the <code>match-template</code> program through Python object and <code>yaml</code> files. Here, we focus on how to create and modify these configurations rather than the underlying code for parsing these configurations and running the program.</p> <p>Rationale for using YAML configurations</p> <p>While the <code>Py2DTM</code> package provides a basic CLI program and an object-oriented Python API for extending template matching into more complex workflows, it is useful to have a human-readable, easily editable, and shareable configuration file because:</p> <ol> <li>It increases reproducibility by keeping a record of exact parameters used for a particular run,</li> <li>It can be quickly modified during development, debugging, and testing without changing underlying code, and</li> <li>It can be replicated across large datasets (e.g. multiple images with similar configurations) for execution on distributed clusters.</li> </ol> <p>We find that storing configurations in a structured file format strikes a good balance between user-friendliness and programmatic control.</p>"},{"location":"examples/basic_configuration/#importing-necessary-classes-and-functions","title":"Importing Necessary Classes and Functions\u00b6","text":"<p>We utilize Pydantic to create Python objects that parse, validate, and serialize configurations. These objects (called Pydantic models) are laid out in a hierarchial structure with a single root \"manager\" model. Below we import all the configuration classes (along with other libraries) we will detail usage of in this notebook.</p>"},{"location":"examples/basic_configuration/#the-opticsgroup-model","title":"The OpticsGroup Model\u00b6","text":"<p>The <code>OpticsGroup</code> model is a container for microscope imaging parameters necessary for calculating filters (e.g. contrast transfer functions). We follow the fields that are defined in RELION's optics group .star file, and the class has the following attributes:</p> <ul> <li><code>label</code>: A unique label for the optics group, usually contains some form of the micrograph name but can be any string.</li> <li><code>pixel_size</code>: Float value representing the pixel size of the image, in Angstroms.</li> <li><code>voltage</code>: The voltage of the microscope, in kV.</li> <li><code>spherical_aberration</code>: The spherical aberration of the microscope, in mm, with the default value of 2.7 mm.</li> <li><code>amplitude_contrast_ratio</code>: The amplitude contrast ratio (unitless) with the default value of 0.07.</li> <li><code>phase_shift</code>: Additional phase shift to apply across the CTF, in degrees, with the default value of 0.0.</li> <li><code>defocus_u</code>: Defocus of the micrograph along the major axis, in Angstroms.</li> <li><code>defocus_v</code>: Defocus of the micrograph along the minor axis, in Angstroms.</li> <li><code>astigmatism_angle</code>: Angle of the defocus astigmatism (relative to the x-axis), in degrees. The default value is 0.0.</li> <li><code>ctf_B_factor</code>: An additional b-factor to apply to the CTF, in Angstroms^2. The default value is 0.0.</li> </ul> <p>There are other unused fields in the class that are not detailed here. See the Pydantic model API documentation for more information.</p>"},{"location":"examples/basic_configuration/#creating-an-instance-of-the-opticsgroup-model","title":"Creating an instance of the OpticsGroup model\u00b6","text":"<p>Below, we create an instance of the <code>OpticsGroup</code> model with some made-up but nevertheless realistic values.</p>"},{"location":"examples/basic_configuration/#serializing-an-instance-of-the-opticsgroup-model","title":"Serializing an instance of the OpticsGroup model\u00b6","text":"<p>Pydantic has built-in functionality, namely the <code>model_dump()</code>, for generating a dictionary of key, value pairs from the model attributes and their values. Below, we create a dictionary from the <code>my_optics_group</code> instance and print it out. Note that extra, unused fields are still included in the dictionary.</p>"},{"location":"examples/basic_configuration/#exporting-configurations-to-a-yaml-file","title":"Exporting configurations to a YAML file\u00b6","text":"<p>YAML files are nothing more than a bunch of key-value pairs in a human-readable format. Like JSON, YAML has parser functions/libraries in most programming languages increasing their interoperability. We adopt the <code>.yaml</code> format (and <code>.json</code> format, but not discussed here) for our configuration files rather than less-common formats specific to a sub-field or program.</p> <p>The <code>OpticsGroup</code> model (and all the other Pydanic models discussed here) have a <code>to_yaml()</code> method that writes the model to a YAML file. Below, we first specify a path and then call the <code>to_yaml()</code> method on the <code>my_optics_group</code> instance to write the model to a file.</p>"},{"location":"examples/basic_configuration/#importing-configurations-from-a-yaml-file","title":"Importing configurations from a YAML file\u00b6","text":"<p>Each model also has the <code>from_yaml()</code> method which can be to instantiate the class from contents in a <code>.yaml</code> file. Below, we are creating a new instance of the <code>OpticsGroup</code> class from the <code>optics_group.yaml</code> file.</p>"},{"location":"examples/basic_configuration/#the-orientationsearchconfig-model","title":"The OrientationSearchConfig Model\u00b6","text":"<p>Two-dimensional template matching necessitates covering SO(3) orientation space to find the \"best\" orientation match for a particle. How points are sampled during the search process is handled by the <code>OrientationSearchConfig</code> model. This model effectively acts as an interface with the torch-so3 package, which provides the underlying functionality for generating uniform grids on SO(3).</p> <p>The class has the following attributes:</p> <ul> <li><code>in_plane_step</code>: The in-plane step size (in units of degrees) with a default value of 1.5 degrees.</li> <li><code>out_of_plane_step</code>: The out-of-plane step size (in units of degrees) with a default value of 2.5 degrees.</li> <li><code>phi_min</code>: The minimum value for the $\\phi$ Euler angle (in degrees) with a default value of 0.0.</li> <li><code>phi_max</code>: The maximum value for the $\\phi$ Euler angle (in degrees) with a default value of 360.0.</li> <li><code>theta_min</code>: The minimum value for the $\\theta$ Euler angle (in degrees) with a default value of 0.0.</li> <li><code>theta_max</code>: The maximum value for the $\\theta$ Euler angle (in degrees) with a default value of 180.0.</li> <li><code>psi_min</code>: The minimum value for the $\\psi$ Euler angle (in degrees) with a default value of 0.0.</li> <li><code>psi_max</code>: The maximum value for the $\\psi$ Euler angle (in degrees) with a default value of 360.0.</li> <li><code>base_grid_method</code>: The method used to generate the base S2 grid. Allowed values are <code>\"uniform\"</code> and <code>\"healpix\"</code>. The default value is <code>\"uniform\"</code>.</li> </ul> <p>Note that the default min/max values set the search space to cover SO(3) for a particle with <code>\"C1\"</code> symmetry.</p>"},{"location":"examples/basic_configuration/#the-defocussearchconfig-model","title":"The DefocusSearchConfig Model\u00b6","text":"<p>Two-dimensional template matching is also sensitive to the relative defocus of a particle allowing the estimation of the Z-height in a sample. The <code>DefocusSearchConfig</code> model handles which defocus planes are searched over (relative to the defocus parameters defined in the <code>OpticsGroup</code> model).</p> <p>The model has the following attributes:</p> <ul> <li><code>enabled</code>: A boolean value indicating whether defocus search is enabled. The default value is <code>True</code>. If <code>False</code>, then only the defocus value defined in the <code>OpticsGroup</code> model is used.</li> <li><code>defocus_min</code>: The minimum relative defocus value (in Angstroms) to search.</li> <li><code>defocus_max</code>: The maximum relative defocus value (in Angstroms) to search.</li> <li><code>defocus_step</code>: The increment between searched defocus planes (in Angstroms).</li> </ul> <p>These parameters will generate a set of relative defocus planes searched over according to $$[\\text{f}_\\text{min}, \\text{f}_\\text{min} + \\Delta\\text{f}, + \\text{f}_\\text{min} + 2\\Delta\\text{f}, \\dots, \\text{f}_\\text{max}]$$ which is effectively the following range object in Python:</p> <pre>range(defocus_min, defocus_max + defocus_step, defocus_step)\n</pre>"},{"location":"examples/basic_configuration/#the-defocussearchconfigdefocus_values-property","title":"The <code>DefocusSearchConfig.defocus_values</code> property\u00b6","text":"<p>Once a <code>DefocusSearchConfig</code> model is instantiated, there is the helpful <code>defocus_values</code> property that returns a list of relative defocus values to search over.</p>"},{"location":"examples/basic_configuration/#fourier-filters-in-the-preprocessingfilters-model","title":"Fourier filters in the PreprocessingFilters Model\u00b6","text":"<p>Template matching necessitates the use of Fourier filters to preprocess the input image (e.g. spectral whitening). The <code>PreprocessingFilters</code> model handles the configuration of the following filter types:</p> <ul> <li>Spectral whitening under the <code>whitening_filter</code> attribute</li> <li>Bandpass filtering, with the option for smooth transitions, under the <code>bandpass_filter</code> attribute.</li> <li>Phase randomization above a certain frequency using the <code>phase_randomization_filter</code> attribute.</li> <li>Options for a user-defined arbitrary curve filter under the <code>arbitrary_curve_filter</code> attribute.</li> </ul> <p>Together, all these filter types allow fine control over how an input image is preprocessed before template matching. Each filter type is itself a Pydantic model with its own set of attributes.</p>"},{"location":"examples/basic_configuration/#whiteningfilterconfig","title":"WhiteningFilterConfig\u00b6","text":"<p>The <code>WhiteningFilterConfig</code> model handles the configuration of the spectral whitening filter. When applied the image, the power spectral density should become flat and the noise distribution is white (i.e. uncorrelated).</p> <p>The whitening filter is enabled by default and has the following attributes:</p> <ul> <li><code>enabled</code>: A boolean value indicating whether the whitening filter is enabled.</li> <li><code>num_freq_bins</code>: An optional integer specifying the number of frequency bins used when calculating the power spectral density. This parameter is automatically calculated based on the input image size if not provided.</li> <li><code>max_freq</code>: An optional float specifying the maximum spatial frequency (in terms of Nyquist) to use when calculating the whitening filter. Frequencies above this value are set to <code>1.0</code>, that is, unscaled. The default value is <code>0.5</code> which corresponds to the Nyquist frequency.</li> <li><code>do_power_spectrum</code>: Boolean indicating weather the whitening filter should be calculated over the power spectrum or amplitude spectrum. The default value is <code>True</code> and the power spectrum is used.</li> </ul> <p>Below, we create a default instance of the <code>WhiteningFilterConfig</code> model.</p>"},{"location":"examples/basic_configuration/#bandpassfilterconfig","title":"BandpassFilterConfig\u00b6","text":"<p>The <code>BandpassFilterConfig</code> model handles the configuration of the bandpass filter.</p> <p>The bandpass filter is disabled by default and has the following attributes:</p> <ul> <li><code>enabled</code>: A boolean value indicating whether the bandpass filter is enabled.</li> <li><code>low_freq_cutoff</code>: The low-pass cutoff frequency (in terms of Nyquist) for the bandpass filter.</li> <li><code>high_freq_cutoff</code>: The high-pass cutoff frequency (in terms of Nyquist) for the bandpass filter.</li> <li><code>falloff</code>: The falloff factor (using a cosine function) for the bandpass filter. A value of <code>0.0</code> (default) corresponds to a hard cutoff with values in the range <code>(0.0, 0.1)</code> providing a smooth, but distinct, transition.</li> </ul> <p>When disabled, the bandpass filter is not applied to the input image. Nonetheless, we create a default instance of the <code>BandpassFilterConfig</code> model below.</p>"},{"location":"examples/basic_configuration/#phaserandomizationfilterconfig","title":"PhaseRandomizationFilterConfig\u00b6","text":"<p>The <code>PhaseRandomizationFilterConfig</code> model hold parameters defining a phase randomization filter. This filter keeps the amplitudes of Fourier components above a certain frequency the same, but randomizes their phases. This is useful for testing the robustness of template matching algorithms to noise.</p> <p>The model is disabled by default has the following attributes:</p> <ul> <li><code>enabled</code>: A boolean value indicating whether the phase randomization filter is enabled.</li> <li><code>cuton</code>: The cuton frequency (in terms of Nyquist) for the phase randomization filter. Frequencies above this value are randomized.</li> </ul> <p>Below, we create a default instance of the <code>PhaseRandomizationFilterConfig</code> model.</p>"},{"location":"examples/basic_configuration/#arbitrarycurvefilterconfig","title":"ArbitraryCurveFilterConfig\u00b6","text":"<p>We also provide a model for defining an arbitrary curve filter for preprocessing. This filter takes a set of spatial frequency values (in terms of Nyquist) and filter amplitudes at those frequencies to create a custom filter. Utilizing this filter allows for fine-grained control over how spatial frequencies should be weighted within the template matching package itself.</p> <p>The model is disabled by default has the following attributes:</p> <ul> <li><code>enabled</code>: A boolean value indicating whether the arbitrary curve filter is enabled.</li> <li><code>frequencies</code>: 1-dimensional list of floats representing the spatial frequencies (in terms of Nyquist). The list must be sorted in ascending order.</li> <li><code>amplitudes</code>: 1-dimensional list of floats representing the filter amplitudes at the corresponding frequencies. The list must be the same length as <code>frequencies</code>.</li> </ul> <p>Below, we create a default instance of the <code>ArbitraryCurveFilterConfig</code> mode; it is disabled and has no frequencies or amplitudes set.</p>"},{"location":"examples/basic_configuration/#putting-the-filters-together-in-the-preprocessingfilters-model","title":"Putting the filters together in the PreprocessingFilters Model\u00b6","text":"<p>We now construct the <code>PreprocessingFilters</code> model with the instances of the four filter models we created above.</p>"},{"location":"examples/basic_configuration/#computationalconfig","title":"ComputationalConfig\u00b6","text":"<p>The <code>ComputationalConfig</code> model currently only handles the GPU ids to use for template matching. The model has the following attributes:</p> <ul> <li><code>gpu_ids</code>: A list of integers representing the GPU ids to use for template matching. The default value is <code>[0]</code> which corresponds to the first GPU.</li> </ul> <p>Below, we create a new instance of the <code>ComputationalConfig</code> model with the default GPU id list.</p>"},{"location":"examples/basic_configuration/#specifying-result-output-with-the-matchtemplateresult-model","title":"Specifying result output with the MatchTemplateResult Model\u00b6","text":"<p>We almost have a complete set of configurations for the <code>match-template</code> program, but we still need to specify where to save results after the program completes. The <code>MatchTemplateResult</code> model handles this by specifying output file paths. The model also has handy class methods for analyzing results and picking particles, but this is discussed elsewhere in the documentation.</p>"},{"location":"examples/basic_configuration/#user-definable-attributes","title":"User-definable attributes\u00b6","text":"<p>The model has the following user-definable attributes:</p> <ul> <li><code>allow_file_overwrite</code>: A boolean value indicating whether the program should be allowed to overwrite existing files. The default value is <code>False</code> and will raise an error if a file already exists.</li> <li><code>mip_path</code>: The path to save the maximum intensity projection (MIP) image.</li> <li><code>scaled_mip_path</code>: The path to save the scaled MIP (a.k.a z-score or SNR) image.</li> <li><code>correlation_average_path</code>: The path to save the average correlation value per pixel.</li> <li><code>correlation_variance_path</code>: The path to save the variance of the correlation value per pixel.</li> <li><code>orientation_psi_path</code>: The path to save the best $\\psi$ Euler angle map.</li> <li><code>orientation_theta_path</code>: The path to save the best $\\theta$ Euler angle map.</li> <li><code>orientation_phi_path</code>: The path to save the best $\\phi$ Euler angle map.</li> <li><code>relative_defocus_path</code>: The path to save the best relative defocus map.</li> </ul>"},{"location":"examples/basic_configuration/#attributes-updated-after-template-matching","title":"Attributes updated after template matching\u00b6","text":"<p>There are additional attributes in the model which automatically get updated after template matching is complete:</p> <ul> <li><code>total_projections</code>: The total number of projections (\\text{orientations} \\times \\text{defocus planes}) searched over.</li> <li><code>total_orientations</code>: The total number of orientations searched over.</li> <li><code>total_defocus</code>: The total number of defocus planes searched over.</li> </ul>"},{"location":"examples/basic_configuration/#creating-an-instance-of-the-matchtemplateresult-model","title":"Creating an instance of the MatchTemplateResult model\u00b6","text":"<p>Below, we specify the necessary output paths for the <code>MatchTemplateResult</code> model. Note that this configuration will output the images into thee current working directory. You will need to update these paths to whatever is appropriate for your system.</p>"},{"location":"examples/basic_configuration/#root-matchtemplateconfig-model","title":"Root MatchTemplateConfig Model\u00b6","text":"<p>Finally, we have all the components which go into the root <code>MatchTemplateConfig</code> model. This model is the top-level configuration object that contains all the other models as attributes along with <code>micrograph_path</code> and <code>template_volume_path</code> which point to the input micrograph and simulated reference template volume, respectfully.</p> <p>Below, we create our instance of the <code>MatchTemplateConfig</code> model. Note that you will need to supply the paths to the micrograph and template volume on your system; dummy paths are provided here so the code runs without error.</p>"},{"location":"examples/basic_configuration/#serializing-the-matchtemplateconfig-model","title":"Serializing the MatchTemplateConfig model\u00b6","text":"<p>Like discussed before, we can serialize and read the <code>MatchTemplateConfig</code> model to/from a YAML file. Below, we write the model to a file called <code>match_template_example.yaml</code>.</p>"},{"location":"examples/basic_configuration/#importing-the-matchtemplateconfig-model-from-a-yaml-file","title":"Importing the MatchTemplateConfig model from a YAML file\u00b6","text":"<p>Now, we re-import the configuration into a new model and check that they are the same.</p>"},{"location":"examples/basic_configuration/#conclusion","title":"Conclusion\u00b6","text":"<p>We have now covered the creation, serialization, and deserialization of all the configuration models necessary for the <code>match-template</code> program. This script will create the <code>match_template_example.yaml</code> file in the current working directory whose file contents should match what is listed below. Modifying this file and using it as input to the <code>match-template</code> program will allow you to run the program with the specified configurations. Note that a default YAML configuration can also be found in the GitHub page.</p> <pre>computational_config:\n  gpu_ids:\n  - 0\n  num_cpus: 1\ndefocus_search_config:\n  defocus_max: 600.0\n  defocus_min: -600.0\n  defocus_step: 200.0\n  enabled: true\nmatch_template_result:\n  allow_file_overwrite: true\n  correlation_average_path: ./output_correlation_average.mrc\n  correlation_variance_path: ./output_correlation_variance.mrc\n  mip_path: ./output_mip.mrc\n  orientation_phi_path: ./output_orientation_phi.mrc\n  orientation_psi_path: ./output_orientation_psi.mrc\n  orientation_theta_path: ./output_orientation_theta.mrc\n  relative_defocus_path: ./output_relative_defocus.mrc\n  scaled_mip_path: ./output_scaled_mip.mrc\n  total_defocus: 0\n  total_orientations: 0\n  total_projections: 0\nmicrograph_path: ./dummy_micrograph.mrc\noptics_group:\n  amplitude_contrast_ratio: 0.07\n  beam_tilt_x: null\n  beam_tilt_y: null\n  chromatic_aberration: 0.0\n  ctf_B_factor: 60.0\n  astigmatism_angle: 25.0\n  defocus_u: 5200.0\n  defocus_v: 4950.0\n  even_zernike: null\n  label: my_optics_group\n  mtf_reference: null\n  mtf_values: null\n  odd_zernike: null\n  phase_shift: 0.0\n  pixel_size: 1.06\n  spherical_aberration: 2.7\n  voltage: 300.0\n  zernike_moments: null\norientation_search_config:\n  base_grid_method: uniform\n  in_plane_step: 4.0\n  out_of_plane_step: 4.0\n  phi_max: 360.0\n  phi_min: 0.0\n  psi_max: 360.0\n  psi_min: 0.0\n  theta_max: 180.0\n  theta_min: 0.0\npreprocessing_filters:\n  arbitrary_curve_filter:\n    amplitudes: null\n    enabled: false\n    frequencies: null\n  bandpass_filter:\n    enabled: false\n    falloff: null\n    high_freq_cutoff: null\n    low_freq_cutoff: null\n  phase_randomization_filter:\n    cuton: null\n    enabled: false\n  whitening_filter:\n    do_power_spectrum: true\n    enabled: true\n    max_freq: 0.5\n    num_freq_bins: null\ntemplate_volume_path: ./dummy_template_volume.mrc\n</pre>"}]}